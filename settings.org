#+setupfile: "~/.emacs.d/public/blog/setup-it.org"

#+LANGUAGE: ru
#+PROPERTY: results silent

* DONE Мой конфиг Emacs в формате org-mode                            :emacs:
  :PROPERTIES:
  :EXPORT_FILE_NAME: my-emacs-config
  :END:

** Описание

Этот конфиг использую на всех десктопах и телефонах. Постепенно он пополняется. Актуальную версию всегда можно найти в рабочем репозитории:
[[https://github.com/johnlepikhin/emacs-public/blob/master/settings.org]].

Из него динамически подгружается файл ~/.emacs.d/local.org — настройки email, имени пользователя, личные настройки шаблонов agenda, личные
шаблоны org-записей, почтовые аккаунты и шаблоны.

*** Как подключать

 В ~/.emacs надо написать:

 #+BEGIN_EXAMPLE
 (package-initialize)

 (defun my-load-org-config (subpath)
   (let ((ini-file (expand-file-name subpath user-emacs-directory)))
	 (condition-case errinfo (org-babel-load-file ini-file)
	   (error (message "Cannot load settings for file %s: %s" ini-file errinfo)))))

 (my-load-org-config "public/settings.org")
 #+END_EXAMPLE

 Здесь public/settings.org будет транслировано в ~/.emacs.d/public/settings.org, согласно значению user-emacs-directory.

** Базовая конфигурация

 Все переменные здесь лексически локальны:

#+BEGIN_SRC emacs-lisp
(setq-local lexical-binding t)
#+END_SRC

Собрать информацию по use-package. После загрузки можно позвать функци use-package-report и посмотреть.

#+BEGIN_SRC emacs-lisp
(setq use-package-compute-statistics t)
#+END_SRC

*** Подключить возможность устанавливать пакеты из quelpa и гита.

(Заменено на straight.el)

#+BEGIN_SRC emacs-lisp
;; (use-package quelpa-use-package
;;   :config
;;   (setq quelpa-checkout-melpa-p nil))
#+END_SRC

*** Поддержка straight.el

#+BEGIN_SRC emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
          "straight/repos/straight.el/bootstrap.el"
          (or (bound-and-true-p straight-base-dir)
              user-emacs-directory)))
        (bootstrap-version 7))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)
#+END_SRC


*** Окружение

#+BEGIN_SRC emacs-lisp
(setenv "PATH" (concat "/home/evgenii/bin:" (getenv "PATH")))
#+END_SRC

*** Бэкапы файлов

#+BEGIN_SRC emacs-lisp
(make-directory "~/.local/var/lib/tmp/emacs/auto-save/" t)
(setq auto-save-file-name-transforms '((".*" "~/.local/var/lib/tmp/emacs/auto-save/" t)))
(setq backup-directory-alist '(("." . "~/.local/var/lib/tmp/emacs/auto-save/")))

;; Do not move the current file while creating backup.
(setq backup-by-copying t)
#+END_SRC


*** Внешний вид

 Некоторые оптимизации:

 #+BEGIN_SRC emacs-lisp
 (setq auto-revert-interval 1            ; Refresh buffers fast
       custom-file (make-temp-file "")   ; Discard customization's
       default-input-method "TeX"        ; Use TeX when toggling input method
       echo-keystrokes 0.1               ; Show keystrokes asap
       inhibit-startup-message t         ; No splash screen please
       initial-scratch-message nil       ; Clean scratch buffer
       sentence-end-double-space nil)    ; No double space


 ; Аккуратно обновляет буфер, по возможности с сохранением позиций курсора и выделения
 (setq revert-buffer-insert-file-contents-function 'revert-buffer-insert-file-contents-delicately)
 #+END_SRC

 Выключить кнопку Insert (включение overwrite-mode):

 #+BEGIN_SRC emacs-lisp
 (define-key global-map [(insert)] nil)
 #+END_SRC

 Выключить тулбар:

 #+BEGIN_SRC emacs-lisp
 (tool-bar-mode -1)
 #+END_SRC

 Ширина заполнения по умолчанию большая, сейчас широкие мониторы:

 #+BEGIN_SRC emacs-lisp
 (setq-default fill-column 120)
 #+END_SRC

 Не надо мне сообщать, что у строки есть продолжение. Просто показывай продолжение на
 следующей строке:

 #+BEGIN_SRC emacs-lisp
 (setq-default truncate-lines t)
 #+END_SRC

Плавный скролинг (начиная с Emacs 29)

#+BEGIN_SRC emacs-lisp
(pixel-scroll-precision-mode)
#+END_SRC


*** Настройка темы

 #+BEGIN_SRC emacs-lisp
   (load-theme 'leuven t)
 #+END_SRC

*** Менеджер пакетов и зависимостей

Фикс для https://www.reddit.com/r/emacs/comments/cdei4p/failed_to_download_gnu_archive_bad_request/

#+BEGIN_SRC emacs-lisp
;(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+END_SRC

Подключить менеджер пакетов:

#+BEGIN_SRC emacs-lisp
(require 'package)

(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t)
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

#+END_SRC

Прибить гвоздями указанные пакеты к репозиториям:

#+BEGIN_SRC emacs-lisp
(add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
#+END_SRC

Поставить перечисленные пакеты, если не установлены:

#+BEGIN_SRC emacs-lisp
(dolist (package
         '(use-package))
  (if (not (package-installed-p package))
    (progn
      (message "Installing package %s" package)
    (package-refresh-contents)
      (package-install package))))
#+END_SRC

Настраиваем use-package:

#+BEGIN_SRC emacs-lisp
(require 'use-package)
;(setq use-package-always-ensure t)
#+END_SRC

Больше дебага для use-package:

#+BEGIN_SRC emacs-lisp
(setq use-package-verbose t)
#+END_SRC

Продублируем определение, подгружающее функции из ~/.emacs:

#+BEGIN_SRC emacs-lisp
(defun my-load-org-config (subpath)
  (let ((ini-file (expand-file-name subpath user-emacs-directory)))
	(condition-case errinfo
		(progn
		  (org-babel-load-file ini-file)
		  (message "Loaded config: %s" subpath))
	  (error (message "Cannot load settings for file %s: %s" ini-file errinfo)))))
#+END_SRC


** Настройки ввода

 У меня переключение раскладки внутри Emacs интегрировано с XMonad. Нижеследующие функции служат этой интеграции.

 #+BEGIN_SRC emacs-lisp
 (defun my-update-cursor ()
   (set-cursor-color
    (if (string= current-input-method "russian-computer") "red" "black")))

 (add-hook 'buffer-list-update-hook 'my-update-cursor)

 (defun my-update-isearch-input-method ()
   (if isearch-mode
       (progn
         (setq isearch-input-method-function input-method-function
               isearch-input-method-local-p t)
         (isearch-update))))

 (defun my-update-input-method ()
   (my-update-isearch-input-method)
   (my-update-cursor))

 (defun my-select-input-eng ()
   (interactive)
   (set-input-method 'rfc1345)
   (my-update-input-method))

 (defun my-select-input-rus ()
   (interactive)
   (set-input-method 'russian-computer)
   (my-update-input-method))

 (global-set-key (kbd "<M-f11>") 'my-select-input-eng)
 (global-set-key (kbd "<C-M-f12>") 'my-select-input-rus)
 (define-key isearch-mode-map (kbd "<M-f11>") 'my-select-input-eng)
 (define-key isearch-mode-map (kbd "<M-f12>") 'my-select-input-rus)
 #+END_SRC

 Странный способ добавить ещё одну раскладку:

 #+BEGIN_SRC emacs-lisp
 (set-input-method 'russian-computer)
 (toggle-input-method)
 #+END_SRC

 Создаем личную карту аккордов:

 #+BEGIN_SRC emacs-lisp
 (defvar my-bindings-map (make-keymap)
   "Мои личные горячие клавиги.")

 (define-minor-mode my-bindings-mode
   "Режим для подключения моих кнопок."
   t nil my-bindings-map)

 (define-key my-bindings-map (kbd "C-c <up>")    'windmove-up)
 (define-key my-bindings-map (kbd "C-c <down>")  'windmove-down)
 (define-key my-bindings-map (kbd "C-c <left>")  'windmove-left)
 (define-key my-bindings-map (kbd "C-c <right>") 'windmove-right)
 (define-key my-bindings-map [C-return] (lambda () (interactive) (point-to-register 'r)))
 (define-key my-bindings-map [M-return] (lambda () (interactive) (jump-to-register 'r)))
 #+END_SRC

 Зачем мне замораживать фреймы?

 #+BEGIN_SRC emacs-lisp
 (global-unset-key (kbd "C-z"))
 #+END_SRC

*** Expand region

 По нажатию ~C-=~ выбранный регион семантически/синтаксически расширяется:

 #+BEGIN_SRC emacs-lisp
 (use-package
   expand-region
   :bind (:map my-bindings-map
               ("C-=" . er/expand-region)))
 #+END_SRC

** Внешний вид

Золотое сечение для расположения окон:

 #+BEGIN_SRC emacs-lisp
 (use-package zoom
   :commands zoom-mode
   :config
   (setq zoom-ignored-major-modes '(gnus-summary-mode))
   (setq zoom-size '(0.618 . 0.618)))
 (zoom-mode t)
 #+END_SRC

Удобное хождение по окнам:

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :defer t
  :bind (:map my-bindings-map
              ("M-o" . ace-window)))
#+END_SRC

Подсказка по вводимым кнопкам. Отображать с задержкой в 1 секунду:

 #+BEGIN_SRC emacs-lisp
 (use-package
   which-key
   :config
   (setq which-key-idle-delay 1)
   (which-key-mode))
 #+END_SRC

Показывать в минибуфере позицию в строке:

 #+BEGIN_SRC emacs-lisp
 (column-number-mode)
 #+END_SRC

Подсвечивать пробелы в конце строки:

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (setq-local show-trailing-whitespace t)))
(add-hook 'yaml-mode-hook (lambda () (setq-local show-trailing-whitespace t)))
#+END_SRC

Подсвечивать пустые строчки в конце буфера:

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (setq-local indicate-empty-lines t)))
(add-hook 'yaml-mode-hook (lambda () (setq-local indicate-empty-lines t)))
#+END_SRC

Показывать окончание буфера:

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (setq-local indicate-buffer-boundaries 'left)))
(add-hook 'yaml-mode-hook (lambda () (setq-local indicate-buffer-boundaries 'left)))
#+END_SRC

Отключить изменение размера шрифта скроллингом:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-<wheel-up>") nil)
(global-set-key (kbd "C-<wheel-down>") nil)
#+END_SRC


*** Imenu

#+BEGIN_SRC emacs-lisp
(use-package
  imenu
  :bind (:map my-bindings-map
              ("M-'" . imenu-list-smart-toggle)))
#+END_SRC


*** Выключить menu-bar, показывать по F10

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)

(defun my-toggle-menu-bar ()
  (interactive)
  (toggle-menu-bar-mode-from-frame 'toggle))

(define-key my-bindings-map (kbd "<f10>") 'my-toggle-menu-bar)
#+END_SRC


*** rainbow delimiters

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :config
  (set-face-foreground 'rainbow-delimiters-depth-1-face "#c66")
  (set-face-foreground 'rainbow-delimiters-depth-2-face "#6c6")
  (set-face-foreground 'rainbow-delimiters-depth-3-face "#69f")
  (set-face-foreground 'rainbow-delimiters-depth-4-face "#cc6")
  (set-face-foreground 'rainbow-delimiters-depth-5-face "#6cc")
  (set-face-foreground 'rainbow-delimiters-depth-6-face "#c6c")
  (set-face-foreground 'rainbow-delimiters-depth-7-face "#ccc")
  (set-face-foreground 'rainbow-delimiters-depth-8-face "#999")
  (set-face-foreground 'rainbow-delimiters-depth-9-face "#666"))
#+END_SRC

** Поведение

 Бэкапы не нужны:

 #+BEGIN_SRC emacs-lisp
 (setq backup-inhibited t)
 #+END_SRC

 Шаг отступа по умолчанию 4 символа:

 #+BEGIN_SRC emacs-lisp
 (setq-default tab-width 4) 
 (setq-default standart-indent 4)
 #+END_SRC

 Я люблю ограничивать область видимости до выбранного региона, не надо меня ворнить:

 #+BEGIN_SRC emacs-lisp
 (put 'narrow-to-region 'disabled nil)
 #+END_SRC

 История открытых файлов:

 #+BEGIN_SRC emacs-lisp
 (use-package
   recentf
   :config
   (setq recentf-max-saved-items 100)
   (setq recentf-max-menu-items 25)
   (recentf-mode 1))
 #+END_SRC

 Помнить позиции в файлах:

 #+BEGIN_SRC emacs-lisp
 (save-place-mode 1)
 #+END_SRC

 Поминить историю команд минибуфера:

 #+BEGIN_SRC emacs-lisp
 (savehist-mode 1)
 #+END_SRC

 Браузер по умолчанию — google-chrome-beta:

 #+BEGIN_SRC emacs-lisp
 (setq browse-url-browser-function 'browse-url-generic
       browse-url-generic-program "google-chrome-beta")
 ;; (setq browse-url-browser-function 'browse-url-chromium)
 #+END_SRC

Использовать ivy в качестве движка автодополнения имен буферов, файлов и т.д.

[2019-09-23 Mon] закомментил т.к. тормозит на больших файлах.

# #+BEGIN_SRC emacs-lisp
# (use-package ivy
#   :defer 0.1
#   :diminish
#   :bind (("C-c C-r" . ivy-resume)
#          ("C-x B" . ivy-switch-buffer-other-window))
#   :custom
#   (ivy-count-format "(%d/%d) ")
#   (ivy-use-virtual-buffers t)
#   :config (ivy-mode))

# (use-package counsel
#   :after ivy
#   :config (counsel-mode))
# #+END_SRC

Ищем swiper'ом:

[2019-09-23 Mon] закомментил т.к. тормозит на больших файлах.

# #+BEGIN_SRC emacs-lisp
# (use-package swiper
#   :after ivy
#   :bind (("C-s" . swiper)
#          ("C-r" . swiper)))
# #+END_SRC

Показывать только ошибки высокого уровня тревожности:

#+BEGIN_SRC emacs-lisp
(setq warning-minimum-level :emergency)
#+END_SRC



*** Правильный список буферов

[2019-09-23 Mon] закомментил т.к. тормозит на больших файлах.

#     #+BEGIN_SRC emacs-lisp
# (use-package
#   ibuffer
#   :bind (:map my-bindings-map
#                ("C-x C-b" . ibuffer))
#   :hook ((ibuffer-mode . hl-line-mode)))
# #+END_SRC

*** Настройки isearch

 У меня плохо прижились стандартные кнопки, слегка переназначил:

 #+BEGIN_SRC emacs-lisp
 (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat )
 (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance )

 (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward)
 (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward)

 (define-key minibuffer-local-isearch-map (kbd "<left>") 'isearch-reverse-exit-minibuffer)
 (define-key minibuffer-local-isearch-map (kbd "<right>") 'isearch-forward-exit-minibuffer)
 #+END_SRC

*** visual-fill-column

Необходимо например для Gnus

#+BEGIN_SRC emacs-lisp
(use-package visual-fill-column
  :defer t)
#+END_SRC


** Редактирование

Многострочный режим комментариев по умолчанию

 #+BEGIN_SRC emacs-lisp
   (setq comment-style 'multi-line)
 #+END_SRC

У нас не принято разделять предложения двойным пробелом:

 #+BEGIN_SRC emacs-lisp
   (setq sentence-end-double-space nil)
 #+END_SRC

Мы презираем табулялцию в отступах:

 #+BEGIN_SRC emacs-lisp
   (setq-default indent-tabs-mode nil)
 #+END_SRC

Фиксим Delete, стирающую не туда

 #+BEGIN_SRC emacs-lisp
   (normal-erase-is-backspace-mode 1)
 #+END_SRC

Backspace/delete должны удалять выделенный текст:

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC


*** Yasnippet: разворачивание сниппетов

 #+BEGIN_SRC emacs-lisp
 (use-package yasnippet
   :ensure t
   :bind
   (:map my-bindings-map
         ("C-<tab>" . yas-expand))
   ;; я не люблю, когда по tab-у мне пытаются что-то развернуть
   (:map yas-minor-mode-map
         ("<tab>" . nil)
         ("TAB" . nil))
   :hook ((prog-mode org-mode) . yas-minor-mode)
   :commands (yas-minor-mode)
   :after (yasnippet-classic-snippets)
   :config
   ;; подключить мой публичный репозиторий сниппетов
   (add-to-list 'yas-snippet-dirs (expand-file-name "~/.emacs.d/public/yasnippets"))
   ;; теперь надо всё перечитать
   (yas-reload-all))

 (use-package yasnippet-classic-snippets)
 #+END_SRC

*** Удаление без пополнения kill-ring

 Не люблю, когда удаляемые куски текста автоматом копируются в буфер обмена. Кусочки кода откуда-то спёр.

 #+BEGIN_SRC emacs-lisp
 (defun my-delete-word (arg)
   "Delete characters forward until encountering the end of a word.
 With argument, do this that many times.
 This command does not push text to `kill-ring'."
   (interactive "p")
   (delete-region
    (point)
    (progn
      (forward-word arg)
      (point))))

 (defun my-backward-delete-word (arg)
   "Delete characters backward until encountering the beginning of a word.
 With argument, do this that many times.
 This command does not push text to `kill-ring'."
   (interactive "p")
   (my-delete-word (- arg)))

 (define-key my-bindings-map (kbd "C-S-k") 'my-delete-line-backward)
 (define-key my-bindings-map (kbd "M-d") 'my-delete-word)
 (define-key my-bindings-map (kbd "<M-backspace>") 'my-backward-delete-word)
 (define-key my-bindings-map (kbd "<C-backspace>") 'my-backward-delete-word)
 #+END_SRC

*** Показывать отступы

Отключить режим для файлов больше 100K:

#+BEGIN_SRC emacs-lisp
  (defun my-disable-indent-guide-mode-for-big-buffer ()
    (when (> (buffer-size) 100000)
      (progn
        (message "Buffer is too big, disable guided indent mode")
        (indent-guide-mode -1))))
#+END_SRC

 #+BEGIN_SRC emacs-lisp
   (use-package indent-guide
     :hook ((prog-mode . indent-guide-mode)
            (yaml-mode . indent-guide-mode)
            (find-file . my-disable-indent-guide-mode-for-big-buffer))
     :config
     (setq indent-guide-char "|")
     (set-face-foreground 'indent-guide-face "darkgray"))
 #+END_SRC

*** Умные скобочки

 #+BEGIN_SRC emacs-lisp
   (use-package smartparens
     :config
     ;; Есть баг с electric-parens-mode с cperl, заплатка из https://github.com/syl20bnr/spacemacs/issues/480
     (with-eval-after-load 'cperl-mode
       (add-hook 'smartparens-enabled-hook  (lambda () (define-key cperl-mode-map "{" nil)))
       (add-hook 'smartparens-disabled-hook  (lambda () (define-key cperl-mode-map "{" 'cperl-electric-lbrace))))
     ;; Включаем глобально
     (smartparens-global-mode 1))
   #+END_SRC

 Подсвечивать парную скобку, переходы по ним:

 #+BEGIN_SRC emacs-lisp
   (show-paren-mode 1)
   (setq show-paren-delay 0)
   
   (defun match-paren (arg)
     "Go to the matching paren."
     (interactive "p")
     (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
           ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
           (t (self-insert-command (or arg 1)))))

   (define-key my-bindings-map (kbd "C-`") 'match-paren)
 #+END_SRC

*** Дерево отмены

 #+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :bind (:map my-bindings-map
                ("C-x u" . undo-tree-visualize))
    :config
    (setq undo-tree-auto-save-history nil
          undo-tree-visualizer-timestamps t)
    (global-undo-tree-mode 1))
 #+END_SRC

*** Автодополнение

#+BEGIN_SRC emacs-lisp
(use-package company
   :hook (prog-mode . company-mode)
   :config
   ;; сначала ищем в gtags, а если не нашли — смотрим в abbrev
   (add-to-list 'company-backends '(company-gtags :with company-dabbrev))
   ;; по кнопке TAB происходит и дополнение, и выбор варианта
;;   (company-tng-configure-default)
   (setq company-idle-delay 0.1
         company-echo-delay 0
         company-dabbrev-downcase nil
         company-show-numbers t
         company-minimum-prefix-length 2
         company-selection-wrap-around t
         company-transformers '(company-sort-by-occurrence
                                company-sort-by-backend-importance)))
#+END_SRC

**** Автодополнение с неточным совпадением

К сожалению, поддерживает не так много бэкендов company. Я использую только для lisp.

#+BEGIN_SRC emacs-lisp
(use-package company-flx
  :demand t
  :init
  (company-flx-mode +1))
#+END_SRC

**** Документация в company

#+BEGIN_SRC emacs-lisp
(use-package company-quickhelp
  :ensure t
  :hook (global-company-mode . company-quickhelp-mode)
  :commands (company-quickhelp-mode)
  :defer t
  :init (add-hook 'global-company-mode-hook #'company-quickhelp-mode))
#+END_SRC

**** Отображение списка дополнений в отдельном окошке

#+BEGIN_SRC emacs-lisp
;; С копилотом друг друга перекрывают, неудобно

;; (use-package company-box                ;
;;   :straight t
;;   :ensure t
;;   :hook (company-mode . company-box-mode))
#+END_SRC


*** Tramp

 #+BEGIN_SRC emacs-lisp
 (use-package
   tramp
   :config (setq tramp-use-ssh-controlmaster-options nil))
 #+END_SRC


*** Edit server: редактор для input'ов в браузере

 #+BEGIN_SRC emacs-lisp
 (use-package edit-server
   :config
   (edit-server-start))
 #+END_SRC


*** Grammarly

 #+BEGIN_SRC emacs-lisp
 (use-package flycheck-grammarly
   :after (flycheck)
   :config
   (setq flycheck-grammarly-check-time 0.8)
   (flycheck-grammarly-setup))
 #+END_SRC


** Разработка
*** LSP

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :after (yasnippet flycheck)
  :commands lsp
  :hook ((lsp-after-initialize
         . (lambda ()
             (flycheck-add-next-checker 'lsp 'c/c++-clang)
             (flycheck-add-next-checker 'lsp 'python-flake8)))
             ;; (flycheck-add-next-checker 'lsp 'javascript-eslint)))
         (lsp-mode . lsp-enable-which-key-integration))
  :config
  (setq lsp-pylsp-plugins-flake8-max-line-length 120
        lsp-pylsp-server-command '("pylsp" "-vv")
        lsp-pylsp-plugins-flake8-ignore ["E203", "D100", "D101", "D102", "D103", "D104", "D105", "D106", "D107"])
  
  ;; Настройки для gopls
  (setq lsp-go-analyses '((shadow . t)
                          (simplifyslice . t)
                          (staticcheck . t)
                          (unusedparams . t)
                          (unusedvariable . t)
                          (unusedwrite . t)
                          (useany . t)))
  
  ;; Включаем импорт пакетов при сохранении
  (setq lsp-go-imports-local-prefix "")
  
  ;; Включаем поддержку линз кода (code lens)
  (setq lsp-go-codelenses '((gc_details . t)
                            (generate . t)
                            (regenerate_cgo . t)
                            (test . t)
                            (tidy . t)
                            (upgrade_dependency . t)
                            (vendor . t)))
  
  ;; Настройки производительности для больших проектов
  (setq lsp-go-env '((GOFLAGS . "-tags=integration,unit")))
  
  ;; Автоматически использовать gofumpt вместо gofmt если доступен
  (when (executable-find "gofumpt")
    (setq lsp-go-use-gofumpt t)))

(use-package lsp-ui
  :custom-face
  (lsp-ui-sideline-code-action ((t (:foreground "green"))))
  (lsp-ui-sideline-current-symbol ((t (:foreground "orange"))))
  :preface
  (defun ladicle/toggle-lsp-ui-doc ()
    (interactive)
    (if lsp-ui-doc-mode
        (progn
          (lsp-ui-doc-mode -1)
          (lsp-ui-doc--hide-frame))
      (lsp-ui-doc-mode 1)))
  :bind
  (:map lsp-mode-map
        ("C-c C-r" . lsp-ui-peek-find-references)
        ("C-c C-j" . lsp-ui-peek-find-definitions)
        ("C-c i"   . lsp-ui-peek-find-implementation)
        ("C-c m"   . lsp-ui-imenu)
        ("C-c s"   . lsp-ui-sideline-mode)
        ("C-c d"   . ladicle/toggle-lsp-ui-doc))
  :custom
  (lsp-ui-doc-enable nil)
  ;; Не показывать ошибки в сайдлайне т.к. в случае если строчка генерит десятки ошибок — начинаются тормоза интерфейса
  (lsp-ui-sideline-show-diagnostics nil)
  (read-process-output-max (* 1024 1024))
  (gc-cons-threshold (* 1024 10240))
  :config
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]vendor"))
#+END_SRC

*** tree-sitter

#+BEGIN_SRC emacs-lisp
(use-package tree-sitter
  :straight (tree-sitter :type git
                         :host github
                         :repo "ubolonton/emacs-tree-sitter"
                         :files ("lisp/*.el"))
  :hook ((python-mode rustic-mode golang-mode) . tree-sitter-hl-mode)
  :config
  (add-to-list 'tree-sitter-major-mode-language-alist '(rustic-mode . rust))
  (add-to-list 'tree-sitter-major-mode-language-alist '(typescript-ts-mode . typescript))
  (add-to-list 'tree-sitter-major-mode-language-alist '(tsx-ts-mode . typescript))
  (add-to-list 'tree-sitter-major-mode-language-alist '(cperl-mode . perl))
  (add-to-list 'tree-sitter-major-mode-language-alist '(go-mode . go))
  (setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (perl . ("https://github.com/tree-sitter-perl/tree-sitter-perl" "release"))
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
     (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
     (yaml "https://github.com/ikatyang/tree-sitter-yaml"))))


(use-package tree-sitter-langs
  :straight (tree-sitter-langs :type git
                               :host github
                               :repo "ubolonton/emacs-tree-sitter"
                               :files ("langs/*.el" "langs/queries"))
  :after tree-sitter)
#+END_SRC

*** Форматирование кода

#+BEGIN_SRC emacs-lisp
(use-package apheleia
  :ensure apheleia
  :diminish ""
  :defines
  apheleia-formatters
  apheleia-mode-alist
  :functions
  apheleia-global-mode
  :config
  (setf (alist-get 'prettier-json apheleia-formatters)
        '("prettier" "--stdin-filepath" filepath))
  (apheleia-global-mode +1))
#+END_SRC

*** Управление проектами

 Подключаем projectile:

 #+BEGIN_SRC emacs-lisp
   (use-package
     projectile
     :bind (:map projectile-mode-map
                 ("C-c p" . 'projectile-command-map))
     :config (projectile-mode +1))
 #+END_SRC

 Подключаем helm к projectile

 #+BEGIN_SRC emacs-lisp
 (use-package
   helm-projectile
   :after (projectile helm)
   :config (helm-projectile-on))
 #+END_SRC

*** Документирование

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :diminish eldoc-mode
  :config (add-hook 'prog-mode-hook 'eldoc-mode))
#+END_SRC


*** Сборки

#+BEGIN_SRC emacs-lisp
(use-package multi-compile
  :commands (multi-compile multi-compile-run)
  :init
  (setq multi-compile-alist
        '((go-mode . (
                      ("go-build" "go build -v"
                       (locate-dominating-file buffer-file-name ".git"))
                      ("go-build-and-run" "go build -v && echo 'build finish' && eval ./${PWD##*/}"
                       (multi-compile-locate-file-dir ".git"))))
          )))
#+END_SRC


*** Magit

Генератор машиночитаемых коммитов ([[https://www.conventionalcommits.org][conventional commits]]):

#+BEGIN_SRC emacs-lisp
(defun my-magit-generate-conventional-commit-message ()
  "Generates commit message in a style inspired by https://www.conventionalcommits.org/en/v1.0.0/"
  (interactive)
  (let ((type (ido-completing-read "Type: " '("fix" "fix!" "feat" "feat!" "docs" "ci" "refactor" "refactor!") nil t))
        (scope (ido-completing-read "Scope: " '("" "API" "UI" "backend") nil nil "")))
    (insert (format "%s%s: " type (if (string= "" scope) "" (format "(%s)" scope))))))
#+END_SRC

Подключаем magit:

 #+BEGIN_SRC emacs-lisp
 (use-package
   magit
    :bind (:map my-bindings-map
                ("C-x g" . magit-status))
    :hook (git-commit-setup . my-magit-generate-conventional-commit-message))
 #+END_SRC

*** Conventional changelog

Моё поделие для управления версиями проекта и ведения Changelog.org.

#+BEGIN_SRC emacs-lisp
(use-package conventional-changelog
  :straight (:host github :repo "johnlepikhin/el-conventional-changelog" :files ("dist" "*.el")))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (24466 37134 710883 275000) :init (24466 37134 710879 842000) :config (24466 37134 710829 132000) :config-secs (0 0 5 487000) :init-secs (0 0 2422 647000) :use-package-secs (0 53 571255 214000)))

*** Flycheck

 #+BEGIN_SRC emacs-lisp
 (use-package
   flycheck
   :hook ((yaml-mode sh-mode cperl-mode) . flycheck-mode)
   :config
   (setq flycheck-idle-change-delay 5)
   (flycheck-define-checker perl
     "A Perl syntax checker using the Perl interpreter.

     See URL `https://www.perl.org'."
     :command ("perl" "-w" "-c"
               (option-list "-I" flycheck-perl-include-path)
               (option-list "-M" flycheck-perl-module-list concat))
     :standard-input ignore-error
     :error-patterns
     ((error line-start (minimal-match (message))
             " at - line " line
             (or "." (and ", " (zero-or-more not-newline))) line-end))
     :modes (perl-mode cperl-mode)
     :next-checkers (perl-perlcritic))
   (setq 
    ;; Не надо везде включать flycheck, это вредно как минимум при LSP
    ;; flycheck-global-modes '(not org-mode)
    flycheck-global-modes nil
         flycheck-display-errors-function nil
         flycheck-display-errors-delay 0
         ;; Иногда приходится разгребать чуланы с граблями, надо видеть тысячи ошибок в файле
         flycheck-checker-error-threshold 1000))
 #+END_SRC


*** Perl

 Таблица символьного просмотра:

 #+BEGIN_SRC emacs-lisp
 (defun my-cperl-init-prettify-symbols ()
   (setq prettify-symbols-alist
		 '(("<=" . ?≤)
		   ("&&" . ?∧)
		   ("||" . ?∨)
		   ("!=" . ?≠)
		   ("for" . ?∀)
		   ("foreach" . ?∀)
		   ("exists" . ?∃)
		   ("undef" . ?∅)
		   ("sub" . ?λ)
		   ("return" . ?⊢)
		   ("//" . ?⫽)
		   ("my" . ?≡)
		   ("delete" . ?❌)
		   ("defined" . ?❓)
		   ("!" . ?¬)
		   ("not" . ?¬)
		   ("join" . ?𝐉)
		   ("grep" . ?𝐆)
		   ("map" . ?𝐌)
		   ("sort" . ?𝐒)
		   (".." . ?⋰)
		   ("next" . ?↰)
		   ("last" . ?↴)
		   ("while" . ?⮍)
		   ("if" . ?⎧)
		   ("elsif" . ?⎨)
		   ("else" . ?⎩)
		   ("int" . ?ℤ)
		   ("keys" . ?𝐊)
		   ("ne" . ?≭)
		   ("eq" . ?≍)
		   ("->" . ?→)
		   ("=>" . ?⇒)
		   ("=~" .?≈)
		   ("!~" . ?≉)
		   ("$self" . ?◆)))
   (prettify-symbols-mode))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
 (use-package
   cperl-mode
   :ensure-system-package perltidy
   :hook (cperl-mode . tree-sitter-hl-mode)
   :after (flycheck tramp)
   :bind (:map cperl-mode-map ())
   :mode ("\\.\\([pP][Llm]\\|al\\)\\'" . cperl-mode)
   :interpreter (("perl"     . cperl-mode)
                 ("perl5"    . cperl-mode)
                 ("miniperl" . cperl-mode))
   :config 
   ;; perl := cperl
   (defalias 'perl-mode 'cperl-mode)
   ;; C-h P будет показывать perldoc на слово под курсором
   (define-key 'help-command "P" 'cperl-perldoc-at-point)
   ;; я люблю smartparens. Извини, cperl-mode.
   (setq cperl-electric-parens nil)
   ;; Символьное отображение синтаксиса
   (add-hook 'cperl-mode-hook 'my-cperl-init-prettify-symbols)
   ;; Отступ равен 4, не выпендриваться!
   (setq cperl-indent-level 4
         cperl-close-paren-offset -4
         cperl-continued-statement-offset 4
         cperl-indent-parens-as-block t
         cperl-tab-always-indent t)
   ;; Красные хэши меня всегда раздражали
   (face-spec-set 'cperl-hash-face '((t :foreground "darkblue"))))
 #+END_SRC

**** Автодополнение для Perl через PerlySense

 #+BEGIN_SRC emacs-lisp
 (use-package
   company-plsense
   :hook (cperl-mode . company-mode))
 #+END_SRC

*** Ocaml

 #+BEGIN_SRC emacs-lisp
 (use-package tuareg)
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
 (use-package merlin
   :init
   ;; merlin сам их не объявил в зависимости, небольшой костыль
   (use-package iedit)
   (use-package auto-complete)
   :after (tuareg iedit auto-complete)
   :hook ((tuareg-mode . merlin-mode)
          (tuareg-mode . company-mode))
   :config
   (require 'opam-user-setup "~/.emacs.d/opam-user-setup.el"))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
 (use-package flycheck-ocaml
   :after (flycheck merlin)
   :config
   ;; ошибки от мерлина нам не нужны, ведь у нас есть flycheck
   (setq merlin-error-after-save nil)
   (flycheck-ocaml-setup))
 #+END_SRC

*** Coq

#+BEGIN_SRC emacs-lisp
(defun my-coq-mode-setup ()
  (company-coq-mode)
  (setq-local company-minimum-prefix-length 1)
  (setq coq-double-hit-enable t)
  (golden-ratio-mode -1)
  (auto-complete-mode -1))

(use-package proof-general
  :mode ("\\.v$" . coq-mode)
  :hook (coq-mode . my-coq-mode-setup))
#+END_SRC

*** Golang

#+BEGIN_SRC emacs-lisp
(defun my-go-mode-setup ()
  ;; Проверяем наличие gopls
  (if (not (executable-find "gopls"))
      (message "Warning: gopls not found! Please install it with: go install golang.org/x/tools/gopls@latest")
    ;; Запускаем LSP с отложенной инициализацией
    (lsp-deferred))
  
  ;; Включаем дополнительные режимы
  (yas-minor-mode)
  (flycheck-mode)
  (go-guru-hl-identifier-mode)
  
  ;; Настраиваем цепочку проверок: LSP (gopls) -> golangci-lint
  (when (and (featurep 'flycheck-golangci-lint)
             (executable-find "golangci-lint"))
    ;; Убеждаемся, что LSP является основным checker'ом
    (setq-local flycheck-checker 'lsp)
    ;; Добавляем golangci-lint как следующий checker после LSP
    (flycheck-add-next-checker 'lsp 'golangci-lint t))
  
  ;; Хуки для форматирования при сохранении
  (add-hook 'before-save-hook #'lsp-format-buffer t t)
  (add-hook 'before-save-hook #'lsp-organize-imports t t))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :ensure t
  :mode ("\\.go\\'" . go-mode)
  :hook ((go-mode . my-go-mode-setup)
         (completion-at-point-functions . go-complete-at-point)))
#+END_SRC

Подсветка идентификаторов

#+BEGIN_SRC emacs-lisp
(use-package go-guru
  :commands (go-guru-hl-identifier-mode))
#+END_SRC

Линтер

#+BEGIN_SRC emacs-lisp
(use-package flycheck-golangci-lint
  :ensure t
  :after (flycheck lsp-mode)
  :config
  ;; Включаем все проверки golangci-lint
  (setq flycheck-golangci-lint-enable-all t)
  ;; Отключаем дублирующиеся проверки, которые уже выполняет gopls
  (setq flycheck-golangci-lint-disable-linters '("typecheck" "errcheck"))
  ;; Настраиваем golangci-lint как дополнительный checker после LSP
  ;; Это будет настроено в my-go-mode-setup
  )
#+END_SRC

*** Rust

Символьная репрезентация кода

 #+BEGIN_SRC emacs-lisp
 (defun my-rust-init-prettify-symbols ()
   (setq prettify-symbols-alist
         '(("<=" . ?≤)
           ("&&" . ?∧)
           ("!=" . ?≠)
           ("for" . ?∀)
           ("None" . ?∅)
           ("Some" . ?∃)
           ("fn" . ?λ)
           ("return" . ?⊢)
           ("let" . ?≡)
           ("in" . ?∈)
           ("not" . ?¬)
           ;; ("join" . ?𝐉)
           ;; ("filter" . ?⊳)
           ;; ("map" . ?𝐌)
           ;; ("sort" . ?𝐒)
           (".." . ?⋰)
           ;; ("continue" . ?↰)
           ;; ("break" . ?↴)
           ("if" . ?⎧)
           ("else if" . ?⎨)
           ("else" . ?⎩)
           ("enum" . ?ℕ)
           ("struct" . ?𝐔)
           ;; ("self" . ?☐)
           ;; ("mut" . ?✎)
           ;; ("pub" . ?☍)
           ("->" . ?→)
           ("=>" . ?⇒)))
   (prettify-symbols-mode))
 #+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rustic
  :hook ((rustic-mode . my-rust-init-prettify-symbols))
  :bind (:map rustic-mode-map
              ("M-j" . lsp-ui-imenu)
              ("M-?" . lsp-find-references)
              ("C-c C-c a" . lsp-execute-code-action)
              ("C-c C-c r" . lsp-rename))
  :config
  (remove-hook 'rustic-mode-hook 'flycheck-mode)
  :custom
  (rustic-format-trigger 'on-save)
  (rustic-lsp-server 'rust-analyzer)
  ;; (lsp-rust-analyzer-cargo-watch-command "clippy")
  (lsp-rust-analyzer-diagnostics-disabled ["unresolved-proc-macro"])
  (lsp-rust-analyzer-lru-capacity 20))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ron-mode
  :mode ("\\.ron$" . ron-mode)
  :ensure t)
#+END_SRC

 
*** C/C++

#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :defer t
  :hook (((c-mode c++-mode) . my-c-hook)
         ((c-mode c++-mode) . flycheck-mode))
  :init
  (defun my-c-hook ()
    (setf c-basic-offset 4)
    (c-set-offset 'substatement-open 0)
    (c-set-offset 'case-label '+)
    (c-set-offset 'access-label '/)
    (c-set-offset 'label '/))
  :config
  ;; (add-hook 'c-mode-hook #'my-c-hook)
  ;; (add-hook 'c++-mode-hook #'my-c-hook)
  (add-to-list 'c-default-style '(c-mode . "k&r"))
  (add-to-list 'c-default-style '(c++-mode . "k&r")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ccls
  :after cc-mode
  :hook (((c-mode c++-mode) . (lambda () (lsp)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package clang-format+
  :straight (:host github :repo "SavchenkoValeriy/emacs-clang-format-plus" :files ("dist" "*.el")))
#+END_SRC


*** Puppet

#+BEGIN_SRC emacs-lisp
(use-package puppet-mode
  :config
  (setq puppet-indent-level 2)
  (setq puppet-include-indent 2))
#+END_SRC

*** Ansible

#+BEGIN_SRC emacs-lisp
(use-package ansible)
#+END_SRC


*** HTML / JS / typescript

Подключаем web-mode (HTML, JS, CUSS в одном):

 #+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode ("\\.html$" . web-mode)
    :mode ("\\.js$" . web-mode)
    :mode ("\\.jsx$" . web-mode)
    ;; Для TS теперь используем typescript-ts-mode
    ;; :mode ("\\.ts$" . web-mode)
    ;; :mode ("\\.tsx$" . web-mode)
    :hook (web-mode . lsp-deferred)
    :init
    (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-enable-auto-pairing t)
    (setq web-mode-enable-auto-expanding t)
    (setq web-mode-enable-css-colorization t))

 ;; (use-package prettier-js
 ;;   :hook ((web-mode . prettier-js-mode)
 ;;          (tsx-ts-mode . prettier-js-mode)
 ;;          (css-mode-hook . prettier-js-mode))
 ;;   :ensure t)
 #+END_SRC

Typescript с tree-sitter:

#+BEGIN_SRC emacs-lisp
  (use-package typescript-ts-mode
    :ensure t
    :mode ("\\.ts$" . tsx-ts-mode)
    :mode ("\\.tsx$" . tsx-ts-mode)
    :hook (tsx-ts-mode . lsp-deferred)
    :hook (tsx-ts-mode . tree-sitter-hl-mode)
    )
  ;; двойное сохранение ломает линтер/lsp
  ;; :hook (tsx-ts-mode . prettier-js-mode))
#+END_SRC

ESlint:

#+BEGIN_SRC emacs-lisp
(use-package lsp-eslint
  :demand t
  :after lsp-mode)
#+END_SRC

*** YAML

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode ("\\.yaml$" . yaml-mode))
#+END_SRC

*** SQL

#+BEGIN_SRC emacs-lisp
(use-package sql-indent
  :hook (sql-mode . sqlind-minor-mode)
  :commands sqlind-minor-mode)
#+END_SRC

*** Python

#+BEGIN_SRC emacs-lisp
(use-package python-mode
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode))
#+END_SRC

LSP для питона:

#+BEGIN_SRC emacs-lisp
(use-package lsp-python-ms
  :init
  :defer t
  :hook (python-mode . (lambda ()
                         (require 'lsp-python-ms)
                         (lsp))))  ; or lsp-deferred
#+END_SRC

Форматтер:

#+BEGIN_SRC emacs-lisp
(use-package python-black
  :ensure t
  :hook (python-mode . python-black-on-save-mode)
  :after python-mode)
#+END_SRC

Фиксы для Guix:

#+BEGIN_SRC emacs-lisp
(flycheck-define-checker python-flake8
  "A Python syntax and style checker using Flake8.

Requires Flake8 3.0 or newer. See URL
`https://flake8.readthedocs.io/'."
  :command ("flake8"
            "--format=default"
            (config-file "--append-config" flycheck-flake8rc)
            (option "--max-complexity" flycheck-flake8-maximum-complexity nil
                    flycheck-option-int)
            (option "--max-line-length" flycheck-flake8-maximum-line-length nil
                    flycheck-option-int)
            (eval (when buffer-file-name
                    (concat "--stdin-display-name=" buffer-file-name)))
            "-")
  :standard-input t
  :working-directory flycheck-python-find-project-root
  :error-filter (lambda (errors)
                  (let ((errors (flycheck-sanitize-errors errors)))
                    (seq-map #'flycheck-flake8-fix-error-level errors)))
  :error-patterns
  ((warning line-start
            (file-name) ":" line ":" (optional column ":") " "
            (id (one-or-more (any alpha)) (one-or-more digit)) " "
            (message (one-or-more not-newline))
            line-end))
  :enabled (lambda () t)
  :modes (python-mode python-ts-mode)
  :next-checkers ((warning . python-pylint)
                  (warning . python-mypy)))

(add-to-list 'flycheck-checkers 'python-flake8)

(flycheck-define-checker python-pylint
  "A Python syntax and style checker using Pylint.

This syntax checker requires Pylint 1.0 or newer.

See URL `https://www.pylint.org/'."
  ;; --reports=n disables the scoring report.
  :command ("pylint"
            "--reports=n"
            "--output-format=json"
            (config-file "--rcfile=" flycheck-pylintrc concat)
            ;; Need `source-inplace' for relative imports (e.g. `from .foo
            ;; import bar'), see https://github.com/flycheck/flycheck/issues/280
            source-inplace)
  :error-parser flycheck-parse-pylint
  :working-directory flycheck-python-find-project-root
  :enabled (lambda () t)
  :error-explainer (lambda (err)
                     (-when-let (id (flycheck-error-id err))
                       (apply
                        #'flycheck-call-checker-process-for-output
                        'python-pylint nil t
                        (append
                         (flycheck-python-module-args 'python-pylint "pylint")
                         (list (format "--help-msg=%s" id))))))
  :modes (python-mode python-ts-mode)
  :next-checkers ((warning . python-mypy)))

(add-to-list 'flycheck-checkers 'python-pylint)
#+END_SRC


*** Haskell

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package haskell-snippets)
#+END_SRC

*** Guix

#+BEGIN_SRC emacs-lisp
(use-package guix
  :defer t
  ;; :hook (scheme-mode . (global-guix-prettify 'guix-devel))
  :hook
  (after-init . global-guix-prettify-mode)
  (scheme-mode . guix-devel-mode)
  :config
  (setq guix-directory "~/guix/guix")
  (with-eval-after-load 'geiser-guile
    ;; NOTE: "~/.config/guix/latest/" is invaild,
    ;; use "~/.config/guix/latest" instead.
    (add-to-list 'geiser-guile-load-path
                 (concat (file-name-directory (locate-library "geiser.el"))
                         "scheme/guile"))
    (add-to-list 'geiser-guile-load-path "~/guix/guix")
    (add-to-list 'yas-snippet-dirs "~/guix/guix/etc/snippets")))

(if (file-exists-p "~/guix/guix/etc/copyright.el")
    (load-file "~/guix/guix/etc/copyright.el"))

(setq copyright-names-regexp
      (format "%s <%s>" user-full-name user-mail-address))
#+END_SRC

*** Shell

#+BEGIN_SRC emacs-lisp
(use-package flymake-shellcheck
  :commands flymake-shellcheck-load
  :init
  (add-hook 'sh-mode-hook 'flymake-shellcheck-load))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-shell
  :ensure t
  :defer t
  :after company
  :init (add-to-list 'company-backends '(company-shell company-shell-env)))
#+END_SRC

*** Copilot

#+BEGIN_SRC emacs-lisp
(use-package copilot
  :straight (:host github :repo "copilot-emacs/copilot.el" :files ("dist" "*.el"))
  :ensure t
  :hook ((prog-mode yaml-mode) . copilot-mode)
  :config
  (define-key copilot-mode-map (kbd "<M-up>") 'copilot-complete)
  (define-key copilot-mode-map (kbd "<M-right>") 'copilot-accept-completion)
  (define-key copilot-mode-map (kbd "<M-down>") 'copilot-next-completion))
#+END_SRC

*** Graphviz

#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :ensure t
  :config
  (setq graphviz-dot-indent-width 4))
#+END_SRC


** LaTeX

#+BEGIN_SRC emacs-lisp
(use-package tex
  :defer t
  :ensure auctex)
#+END_SRC


*** Форматирование

 Perltidy.el, взято отсюда: https://www.emacswiki.org/emacs/perltidy.el

 #+BEGIN_SRC emacs-lisp
 (defcustom perltidy-program "perltidy"
   "*Program name of perltidy"
   :type 'string
   :group 'perltidy)

 (defcustom perltidy-program-params
   '(;; I/O control
     "--standard-output"
     "--standard-error-output"
     "--force-read-binary"
     "--quiet"

     ;; FORMATTING OPTIONS
     "--no-check-syntax"
     )
   "*perltidy run options"
   :type 'list
   :group 'perltidy)

 (defcustom perltidy-rcregex "\\.perltidyrc"
   "perltidyrc file regex"
   :type 'string
   :group 'perltidy)

 (defun perltidy-buffer ()
   "Call perltidy for whole buffer."
   (interactive)
   (perltidy-region (point-min) (point-max)))
 ;;;###autoload
 (defun perltidy-region (beg end)
   "Tidy perl code in the region."
   (interactive "r")
   (or (get 'perltidy-program 'has-perltidy)
       (if (executable-find perltidy-program)
           (put 'perltidy-program 'has-perltidy t)
         (error "Seem perltidy is not installed")))
     (let ((old-perltidy-env (getenv "PERLTIDY"))
           (remote? (tramp-tramp-file-p buffer-file-name))
           (perltidyrc (perltidy-find-perltidyrc buffer-file-truename))
           (pertidyrc-remote (expand-file-name "perltidyrc-remote" temporary-file-directory))
           (perltidy-run-list perltidy-program-params)
           )

       (if (and (bound-and-true-p remote?)
                perltidyrc)
           (progn
             (require 'tramp-sh)
             (tramp-sh-handle-copy-file perltidyrc pertidyrc-remote t)
             (setq perltidyrc pertidyrc-remote)
             (setq perltidy-run-list
                   (append perltidy-run-list
                           (list (concat "-pro=" pertidyrc-remote))))))

       (apply #'call-process-region
              (append (list beg end perltidy-program
                            t
                            t
                            nil
                            )
                      perltidy-run-list)))
     t)

 (defun perltidy-subroutine ()
   "Call perltidy for subroutine at point."
   (interactive)

   (save-excursion
     (let ((current-point (point))
           b e)
       (setq b (progn (beginning-of-defun) (point)))
       (when (and
              (looking-at "\\s-*sub\\s-+")
              (< b current-point)
              (> (save-excursion
                   (setq e (progn (end-of-defun) (point))))
                 current-point))
         (perltidy-region b e)))))

 (defun perltidy-find-perltidyrc (&optional dir rcregex)
   (unless dir (setq dir (buffer-file-name)))
   (unless rcregex (setq rcregex perltidy-rcregex))
   (setq dir (file-name-directory dir))

   (let (rcfile)
     (catch 'my-tag
       (locate-dominating-file
        dir
        (lambda (parent)
          (let ((rc (car (ignore-errors (directory-files parent t rcregex))))
                (pparent (file-name-directory (directory-file-name parent))))
            (setq rcfile rc)
            (cond ((equal parent
                          pparent)
                   (if (= (length rc) 0)
                       (throw 'my-tag rc)
                     (throw 'my-tag nil)))

                  ((and (= (length rc) 0)
                        (file-exists-p    (expand-file-name "lib" pparent))
                        (file-directory-p (expand-file-name "lib" pparent)))
                   (setq rcfile (car (ignore-errors (directory-files pparent t rcregex))))
                   (throw 'my-tag rcfile))
                  (t rc))))))
     rcfile))
 #+END_SRC

 Perltidy для буфера, текущей функции, строчки и региона:

 #+BEGIN_SRC emacs-lisp
 (defun perl-mode-perltidy ()
   "Perltidy buffer or region if this is perl file."
   (interactive)
   (let ((saved-line (line-number-at-pos)))
     (save-excursion
       (when (eq major-mode 'cperl-mode)
         (if (use-region-p)
             (perltidy-region (region-beginning) (region-end))
           (perltidy-buffer))))
     (forward-line saved-line)))

 (defun my-perltidy-subroutine ()
   "Perltidy current subroutine keeping current position in the buffer as close as possible"
   (interactive)
   (let ((saved-line (line-number-at-pos)))
     (perltidy-subroutine)
     (goto-line saved-line)))

 (defun my-perl-tab-indent ()
   (interactive)
   (if (use-region-p)
       (perltidy-region (region-beginning) (region-end))
     (cperl-indent-command)))

 (use-package
   cperl-mode
   :after (tramp)
   :bind (:map cperl-mode-map
               ("C-c i d" . my-perltidy-subroutine)
               ("C-c i b" . perl-mode-perltidy)
               ("TAB" . my-perl-tab-indent)))
 #+END_SRC

 Вставка JSON из буфера как Perl-структуры. Не спрашивайте, нужно для работы.

 #+BEGIN_SRC emacs-lisp
 (defun my-perl-insert-json ()
   (interactive)
   (shell-command-on-region (point) (point) "xclip -o | json_to_perl.pl" t))

 (use-package
   cperl-mode
   :bind (:map cperl-mode-map
               ("C-c j" . my-perl-insert-json)))
 #+END_SRC

*** Подсветка TODO/FIXME

 #+BEGIN_SRC emacs-lisp
 (use-package fic-mode
  :straight (fic-mode :type git
                         :host github
                         :repo "lewang/fic-mode"
                         :branch "master"
                         :files ("*.el"))
   :hook prog-mode)
 #+END_SRC

*** Цветной compile buffer

#+BEGIN_SRC emacs-lisp
(defun my-colorize-compilation-buffer ()
  (toggle-read-only)
  (ansi-color-apply-on-region compilation-filter-start (point))
  (toggle-read-only))

(use-package ansi-color
  :hook (compilation-filter . my-colorize-compilation-buffer))
#+END_SRC


** PlantUML

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :defer t
  :mode ("\\.plantuml\\'" . plantuml-mode)
  :config
  (setq plantuml-jar-path (concat (getenv "HOME") "/.guix-home/profile/share/java/plantuml.jar"))
  (setq plantuml-default-exec-mode 'jar)
  (setq plantuml-indent-level 2))
#+END_SRC


** Org-mode
*** Основные настройки

 #+BEGIN_SRC emacs-lisp
 (defun my-org-mode-basic-config ()
   ;; По умолчанию таски длятся 1 час
   (setq org-agenda-default-appointment-duration 60)
   ;; SRC-блоки должны выглядеть максимально похоже на исходные режимы редактирования для этих языков
   (setq org-src-fontify-natively t)
   ;; Кнопка tab в SRC-блоках имеет то же поведение, что и в исходных режимах языков
   (setq org-src-tab-acts-natively t)
   ;; Не надо никуда смещать SRC-блоки
   (setq org-edit-src-content-indentation 0)
   ;; Ругаться, если пытаемся редактировать невидимый (напр., схлопнутый) текст
   (setq org-catch-invisible-edits 'error)
   ;; Хочу видеть дату+время, когда пункт был закрыт (CLOSED)
   (setq org-log-done 'time)
   ;; Задаем виды статусов для задач
   (setq org-todo-keywords
       '((sequence "TODO(t)" "WAIT(w)" "VERIFY(v)" "DELEGATED(D@)" "|" "DONE(d)" "CANCELED(c@)")))
   ;; Спрятать лог изменения статусов в LOGGER
   (setq org-log-into-drawer t)
   ;; Разшить refile в мои org-файлы, в поддеревья до глубины 2
   (setq org-refile-targets '((org-agenda-files :maxlevel . 2)))
   ;; При refile показывать также имя файла
   (setq org-refile-use-outline-path 'file)
   ;; Люблю выделять по shift-стрелочки, даже в org-mode
   (setq org-support-shift-select t)
   ;; Отключаем org-persist, кэширование создает тормоза(!)
   (setq org-element-cache-persistent nil)

   ;; Угадывать mode SRC-блоков по названию режимов
   (add-to-list 'org-src-lang-modes '("conf" . conf))
   (add-to-list 'org-src-lang-modes '("ini" . conf))
   (add-to-list 'org-src-lang-modes '("vim" . vimrc))

   ;; Подключить эти модули
   (add-to-list 'org-modules 'org-id)
   (add-to-list 'org-modules 'org-mouse)

   ;; Разукрашиваем статусы
   (setq org-todo-keyword-faces
         '(("WAIT" . (:foreground "#ff8040" :weight bold))
           ("VERIFY" . (:foreground "#afaf00" :weight bold))
           ("CANCELED" . (:foreground "#006000" :weight bold))))

   ;; Подкрасить слова TODO красным в org-файлах
   (face-spec-set 'org-todo '((t :foreground "red")))

   ;; Мне не нравятся большие заголовки 1-го уровня в теме leuven
   (face-spec-set 'org-level-1 '((t :height 1.1)))

   ;; Мне не нравятся большие заголовки в #TITLE
   (face-spec-set 'org-document-title '((t :height 1.2)))
 )
 #+END_SRC

*** Подключение

 #+BEGIN_SRC emacs-lisp
 (defvar my-org-file-main-inbox "~/org/personal/general-TODO.org" "Главный файл для инбокса задач")

 (use-package
   org
   :ensure nil
   :hook ((org-mode . turn-on-flyspell)
          ;; автоматом считывать изменения с диска
          (org-mode . turn-on-auto-revert-mode)
          ;; автосохранение для org-буферов
          ;; (auto-save . org-save-all-org-buffers)
          ;; автоперенос строк по умолчанию
          (org-mode . auto-fill-mode)
          ;; ;; автоматом переносить в архив завершенные задачи с верхнего уровня
          ;; (org-mode . (lambda () (add-hook 'after-save-hook 'org-archive-all-done nil t)))
          ;; выключить включенный теперь везде по умолчанию electric-indent-mode
          ;; в org-mode он по нажатию enter вставляет строчку с отступом
          (org-mode . (lambda () (electric-indent-mode -1))))
   :bind (:map my-bindings-map
               ("C-c l" . org-store-link)
               ("C-c c" . org-capture))
   :config
   (my-org-mode-basic-config)

   (setq
    org-capture-templates
    ;; Главная кнопка добавления задачи
    '(("g" "Общий TODO" entry (file my-org-file-main-inbox)
      "* TODO %?\nSCHEDULED: %t"))))
 #+END_SRC

*** Синхронизация

#+BEGIN_SRC emacs-lisp
(defun git-sync-org-private ()
  (call-process-shell-command "cd ~/org/personal && git-sync" nil 0))

(defun register-git-sync-org-private-hook ()
 (add-hook 'after-save-hook #'git-sync-org-private nil t))

(add-to-list 'safe-local-variable-values '(eval . (register-git-sync-org-private-hook)))
#+END_SRC


** Org agenda

*** Дополнительные функции

 Перечитать известные файлы с диска:

 #+BEGIN_SRC emacs-lisp
 (setq my-org-last-reload (current-time))

 (defun my-org-reload-from-disk (&optional event)
   (interactive)
   ;; релоадить не чаще раза в 3 секунды
   (if (time-less-p (time-add my-org-last-reload 3) (current-time))
	   (progn
		 (setq my-org-last-reload (current-time))
		 (ignore-errors
		   (org-agenda-redo-all)))))
 #+END_SRC

 Заполнить список файлов автоматом, согласно моим правилам. Это делается по крону, через run-with-timer.

 #+BEGIN_SRC emacs-lisp
 (defvar my-org-root-path "~/org" "Path to root directory with org files")
 (defvar my-org-files-regexp "[.]org$" "Regexp to match org files")

 (defun my-org-fill-files-list (&optional EXHAUSTIVE)
   (setq org-agenda-files
         (seq-remove
          (lambda (file) (string-match "[.]#" file))
          (directory-files-recursively my-org-root-path my-org-files-regexp)))
   ;; после пересоздания списков файлов, неплохо бы перечитать их с диска
   (my-org-reload-from-disk))
   ;; (my-org-fill-inotify-handlers))
 #+END_SRC

*** Базовые настройки agenda

 #+BEGIN_SRC emacs-lisp
 (defun my-agenda-mode-setup ()
   (hl-line-mode))

 (defun my-org-agenda-basic-config ()
   ;; Дни рожденния в BBDB брать из поля birthday
   (setq org-bbdb-anniversary-field 'birthday)
   ;; Не показывать DONE в агенде
   (setq org-agenda-skip-scheduled-if-done 't)

   ;; Настройки по умолчанию в теме leuven мне в этом месте не нравятся
   (face-spec-set 'org-agenda-structure '((t :height 1.17)))
   (face-spec-set 'org-agenda-date-today '((t :height 1.1)))
   (face-spec-set 'org-agenda-date '((t :height 1.1)))
   (face-spec-set 'org-agenda-date-weekend '((t :height 1.1))))
 #+END_SRC

*** Автоматическое обновление с диска

#+BEGIN_SRC emacs-lisp
(defadvice revert-buffer (after refresh-org-agenda activate)
  (if (eq major-mode 'org-mode)
      (progn
        (org-agenda-redo-all t)
        ;; С одного раза агенда теперь почему-то не обновляется (с появлением кэшей в org?)
        (org-agenda-redo-all t))))
#+END_SRC


*** Отложенные таски

 Иногда хочется спрятать таск из агенды на определенное время, чтобы глаза мои его не видели.

 Вешаем в agenda-буфере на кнопку C-d функционал откладывания таска:

 #+BEGIN_SRC emacs-lisp
 (defun my-agenda-delayed-tasks-setup ()
   (defun my-org-agenda-delay-task ()
     (interactive)
     (org-agenda-check-no-diary)
     (let* ((hdmarker (or (org-get-at-bol 'org-hd-marker)
                          (org-agenda-error)))
            (buffer (marker-buffer hdmarker))
            (pos (marker-position hdmarker))
            (inhibit-read-only t)
            newhead)
       (org-with-remote-undo buffer
         (with-current-buffer buffer
           (widen)
           (goto-char pos)
           (org-show-context 'agenda)
           (let ((delay (org-read-date 't 'nil 'nil "Отложить до" 'nil
                                       (format-time-string "%H:%M" (time-add (current-time) 3600)))))
             (org-set-property "DELAYED_TILL" delay))))
       (org-agenda-redo-all)))
   (defun my-org-agenda-delay-task-setup-hook ()
     (local-set-key (kbd "\C-c d") 'my-org-agenda-delay-task))
   (add-hook 'org-agenda-mode-hook 'my-org-agenda-delay-task-setup-hook)
 )
 #+END_SRC

 Функция, реализующая пропуск отложенных тасков в agenda-буфере:

 #+BEGIN_SRC emacs-lisp
 (defun my-org-agenda-skip-delayed ()
   (let ((now (format-time-string "%Y-%m-%d %H:%M" (time-add (current-time) 120)))
         (delayed-till (org-read-date t nil (or (org-entry-get nil "DELAYED_TILL") "") nil))
         (subtree-end (save-excursion (org-end-of-subtree t))))
       (if (string> delayed-till now) subtree-end nil)))

 #+END_SRC

*** Горячие кнопки

 Конфигурация команд agenda:

 #+BEGIN_SRC emacs-lisp
 (defun my-org-agenda-commands-config ()
   (setq org-agenda-custom-commands
       '(("d" . "Сегодня")
         ("dd" agenda "Сегодня, все записи"
          ((org-agenda-span 'day)
           (org-agenda-overriding-header "Сегодня, все записи")))
         ("da" agenda "Сегодня, без отложенных"
          ((org-agenda-span 'day)
           (org-agenda-skip-function 'my-org-agenda-skip-delayed)
           (org-agenda-overriding-header "Сегодня, только активные"))))))
 #+END_SRC

*** Подключение

 #+BEGIN_SRC emacs-lisp
 (use-package
     org-agenda
     :ensure nil
     :after (org org-element)
	 :hook (org-agenda-mode . my-agenda-mode-setup)
	 :bind (:map my-bindings-map
				 ("C-c a" . org-agenda))
	 :config
	 (my-org-agenda-basic-config)
	 (my-agenda-delayed-tasks-setup)
	 (my-org-agenda-commands-config)
	 (my-org-fill-files-list))
 #+END_SRC

*** Прочее

 Автосохранение перед выходом:

 #+BEGIN_SRC emacs-lisp
 (advice-add 'org-agenda-quit :before 'org-save-all-org-buffers)
 #+END_SRC

**** Архивирование всех DONE тасков в текущем буфере

 #+BEGIN_SRC emacs-lisp
 (defun my-org-archive-done-tasks ()
   "Archive all DONE tasks in current buffer"
   (interactive)
   (org-map-entries
    (lambda ()
      (org-archive-subtree)
      (setq org-map-continue-from (outline-previous-heading)))
    "/DONE" 'file))
 #+END_SRC

**** Клонировать текущий heading со всеми подзаголовками, со сдвигом всех дат внути

 #+BEGIN_SRC emacs-lisp
 (defun my-org-clone-to-date ()
   "Clone current subtree into specified file with all dates shifted to the same period."
   (interactive)
   (let* ((title (nth 4 (org-heading-components)))
          (orig-date (org-time-string-to-absolute (org-entry-get nil "SCHEDULED")))
          (dest-date (org-time-string-to-absolute
                      (org-read-date nil nil nil (format "Дата для '%s'" title))))
          (offset (format "+%id" (- dest-date orig-date))))
     (org-copy-subtree)
     (with-temp-buffer
       (org-mode)
       (org-paste-subtree)
       (org-clone-subtree-with-time-shift 1 offset)
       (org-forward-element)
       (org-refile))))
 #+END_SRC

** Org export

*** LaTeX

 #+BEGIN_SRC emacs-lisp
 (use-package
   org
   :defer t
   :config
   ;; Какие \usepackage прописывать в LaTeX по умолчанию
   (setq org-latex-default-packages-alist
         '(("utf8" "inputenc" t ("pdflatex"))
           ("T2A" "fontenc" t ("pdflatex"))
           ("english,main=russian" "babel" t)
           ("" "cmap" t)
           ("" "graphicx" t)
           ("" "grffile" t)
           ("" "longtable" nil)
           ("" "wrapfig" nil)
           ("" "rotating" nil)
           ("normalem" "ulem" t)
           ("" "amsmath" t)
           ("" "textcomp" t)
           ("" "tabularx" t)
           ("" "amssymb" t)
           ("" "listings" t)
           ("" "capt-of" nil)
           ("" "hyperref" nil)))
   ;; Для листинга кода использовать пакет listings вместо verbatim-окружений
   (setq org-latex-listings t)
   ;; Файлы с этими расширениями считаются временными при экспорте и будут удалены
   (setq org-latex-logfiles-extensions
         '("aux" "bcf" "blg" "fdb_latexmk" "fls" "figlist" "idx" "log" "nav" "out" "ptc" "run.xml" "snm" "toc" "vrb" "xdv" "tex")))
 #+END_SRC

*** Hugo

**** Базовая настройка

 #+BEGIN_SRC emacs-lisp
 (defun my-org-hugo-add-printable-version (backend)
   (if (eq backend 'hugo)
       (let ((generate-printable (org-entry-get nil "HUGO_GENERATE_PRINTABLE"))
             (file-org-name (buffer-file-name))
             (file-pdf-name (concat (file-name-sans-extension (buffer-file-name)) ".pdf")))
         (if (and generate-printable (string= generate-printable "t"))
             (if (file-newer-than-file-p file-org-name file-pdf-name)
                 (progn
                   (org-latex-export-to-pdf)
                   (find-file file-org-name)
                   (if (not (org-entry-get nil "HUGO_GENERATE_PRINTABLE_ADDED"))
                       (progn
                         (save-excursion
                           (goto-char (point-max))
                           (insert (format "\n** Версия для печати\n\nДля удобства просмотра и печати можно воспользоваться [[file:%s][PDF]]-версией этой статьи." (file-name-nondirectory file-pdf-name))))
                         (org-set-property "HUGO_GENERATE_PRINTABLE_ADDED" "t")
                         (save-buffer)))))))))


 (defun my-org-hugo-add-source-of-article (backend)
   (if (eq backend 'hugo)
       (let* ((generate-printable (org-entry-get nil "HUGO_ADD_ARTICLE_SOURCE"))
             (file-org-name (buffer-file-name))
             (file-org-shortname (file-name-nondirectory file-org-name)))
         (if (and generate-printable (string= generate-printable "t"))
             (progn
               (find-file file-org-name)
               (if (not (org-entry-get nil "HUGO_ADD_ARTICLE_SOURCE_ADDED"))
                   (progn
                     (save-excursion
                       (goto-char (point-max))
                       (insert (format "\n** Исходник статьи\n\nСсылка для скачивания: [[file:%s][%s]]."
                                       file-org-shortname
                                       file-org-shortname)))
                         (org-set-property "HUGO_ADD_ARTICLE_SOURCE_ADDED" "t")
                         (save-buffer))))))))

 (defun my-hyphenize-russian (input hyphen)
   (interactive)
   (with-temp-buffer
     (progn
       (insert input)
       (call-process-region (point-min) (point-max) "~/bin/hyphen/russian/russian-hyphen.pl" t t nil "--hyphenize-stdin" (concat "--hyphen-char=" hyphen))
       (buffer-string))))

 (defun my-hugo-improvements (text backend info)
   (when (org-export-derived-backend-p backend 'hugo)
     (my-hyphenize-russian text "&#173;")))

 (use-package
   ox-hugo
   :after (ox org)
   :ensure t
   :commands (org-hugo-export-wim-to-md)
   :hook ((org-export-before-processing . my-org-hugo-add-printable-version)
          (org-export-before-processing . my-org-hugo-add-source-of-article))
   :config
   (add-to-list 'org-export-filter-plain-text-functions
                'my-hugo-improvements)
   (setq org-hugo-external-file-extensions-allowed-for-copying
         '("jpg" "jpeg" "tiff" "png" "svg" "gif" "pdf" "odt" "doc" "ppt" "xls" "docx" "pptx" "xlsx" "sorg")))
 #+END_SRC

**** Автоматический экспорт (batch mode)

 #+BEGIN_SRC emacs-lisp
 (defvar my-org-blog-path "~/org/personal" "Root path where to find blog articles")

 (defun my-org-hugo-twits-prepare (file)
   (interactive)
   (setq-local org-twit-counter 1)
   (message "Preparing twits...")
   (org-map-entries
    (lambda ()
      (when
          (and
           (not (string= (string-trim (org-entry-get nil "ITEM")) ""))
           (not (org-entry-get nil "EXPORT_FILE_NAME")))
        (progn
          (message (format "Preparing twit '%s'" (org-entry-get nil "ITEM")))
          (org-todo 'done)
          (org-set-property
           "EXPORT_FILE_NAME"
           (format "twit-%s-%i" (format-time-string "%F-%T") org-twit-counter))
          (incf org-twit-counter))))
    "twit"
    (list file)))


 (defun my-org-hugo-export-file (f)
   (interactive)
   (save-excursion
     (message (concat "Processing file " f))
     (find-file f)
     (my-org-hugo-twits-prepare f)
     (save-buffer)
     (org-hugo-export-wim-to-md :all-subtrees nil nil t)
     (kill-buffer (current-buffer))))

 (defun my-org-hugo-export-files-org-personal (&key newer-than)
   (interactive)
   (save-excursion
     (let ((newer-than (seconds-to-time (if (null newer-than) 0 newer-than))))
       (mapc 'my-org-hugo-export-file
             (seq-filter
              (lambda (file)
                (and
                 (not (string-match "/[.]#" file))
                 (time-less-p newer-than (nth 5 (file-attributes file)))))
              (directory-files-recursively my-org-blog-path "\\.s?org$"))))))
 #+END_SRC

**** Экспорт embedded видео в Hugo. Не спрашивайте.

 #+BEGIN_SRC emacs-lisp
 (defun org-image-update-overlay (file link &optional data-p refresh)
   "Create image overlay for FILE associtated with org-element LINK.
         If DATA-P is non-nil FILE is not a file name but a string with the image data.
         See also `create-image'.
         This function is almost a duplicate of a part of `org-display-inline-images'."
   (when (or data-p (file-exists-p file))
     (let ((width
            ;; Apply `org-image-actual-width' specifications.
            (cond
             ((not (image-type-available-p 'imagemagick)) nil)
             ((eq org-image-actual-width t) nil)
             ((listp org-image-actual-width)
              (or
               ;; First try to find a width among
               ;; attributes associated to the paragraph
               ;; containing link.
               (let ((paragraph
                      (let ((e link))
                        (while (and (setq e (org-element-property
                                             :parent e))
                                    (not (eq (org-element-type e)
                                             'paragraph))))
                        e)))
                 (when paragraph
                   (save-excursion
                     (goto-char (org-element-property :begin paragraph))
                     (when
                         (re-search-forward
                          "^[ \t]*#\\+attr_.*?: +.*?:width +\\(\\S-+\\)"
                          (org-element-property
                           :post-affiliated paragraph)
                          t)
                       (string-to-number (match-string 1))))))
               ;; Otherwise, fall-back to provided number.
               (car org-image-actual-width)))
             ((numberp org-image-actual-width)
              org-image-actual-width)))
           (old (get-char-property-and-overlay
                 (org-element-property :begin link)
                 'org-image-overlay)))
       (if (and (car-safe old) refresh)
           (image-refresh (overlay-get (cdr old) 'display))
         (let ((image (create-image file
                                    (and width 'imagemagick)
                                    data-p
                                    :width width)))
           (when image
             (let* ((link
                     ;; If inline image is the description
                     ;; of another link, be sure to
                     ;; consider the latter as the one to
                     ;; apply the overlay on.
                     (let ((parent
                            (org-element-property :parent link)))
                       (if (eq (org-element-type parent) 'link)
                           parent
                         link)))
                    (ov (make-overlay
                         (org-element-property :begin link)
                         (progn
                           (goto-char
                            (org-element-property :end link))
                           (skip-chars-backward " \t")
                           (point)))))
               (overlay-put ov 'display image)
               (overlay-put ov 'face 'default)
               (overlay-put ov 'org-image-overlay t)
               (overlay-put
                ov 'modification-hooks
                (list 'org-display-inline-remove-overlay))
               (push ov org-inline-image-overlays))))))))

 ;; youtube

 (defvar yt-iframe-format
   (concat "<div class=\"yt-container\"><iframe src=\"https://www.youtube.com/embed/%s\""
           " frameborder=\"0\""
           " allowfullscreen>%s</iframe></div>"))

 (defvar yt-hugo-format "{{< youtube id=\"%s\" >}}")

 (org-link-set-parameters
  "yt"
  :follow (lambda (handle)
            (browse-url
             (concat "https://www.youtube.com/embed/"
                     handle)))
  :export (lambda (path desc backend)
            (cl-case backend
              (md (format yt-hugo-format path))
              (html (format yt-iframe-format path (or desc "")))
              (latex (format "\href{%s}{%s}"
                             path (or desc "video"))))))

 (defun org-yt-get-image (url)
   "Retrieve image from url."
   (let ((image-buf (url-retrieve-synchronously url)))
     (when image-buf
       (with-current-buffer image-buf
         (goto-char (point-min))
         (when (looking-at "HTTP/")
           (delete-region (point-min)
                          (progn (re-search-forward "\n[\n]+")
                                 (point))))
         (setq image-data (buffer-substring-no-properties (point-min) (point-max)))))))

 (defconst org-yt-video-id-regexp "[-_[:alnum:]]\\{10\\}[AEIMQUYcgkosw048]"
   "Regexp matching youtube video id's taken from `https://webapps.stackexchange.com/questions/54443/format-for-id-of-youtube-video'.")

 (defun org-yt-display-inline-images (&optional include-linked refresh beg end)
   "Like `org-display-inline-images' but for yt-links."
   (when (display-graphic-p)
     (org-with-wide-buffer
      (goto-char (or beg (point-min)))
      (let ((re (format "\\[\\[%s:\\(%s\\)\\]\\]" "yt" org-yt-video-id-regexp)))
        (while (re-search-forward re end t)
          (let ((video-id (match-string 1))
                (el (save-excursion (goto-char (match-beginning 1)) (org-element-context)))
                image-data)
            (when el
              (setq image-data 
                    (or (let ((old (get-char-property-and-overlay
                                    (org-element-property :begin el)
                                    'org-image-overlay)))
                          (and old
                               (car-safe old)
                               (overlay-get (cdr old) 'display)))
                        (org-yt-get-image (format "http://img.youtube.com/vi/%s/0.jpg" video-id))))
              (when image-data
                (org-image-update-overlay image-data el t t)))))))))

 (use-package
   org
   :ensure nil
   :config (advice-add #'org-display-inline-images :after #'org-yt-display-inline-images))
 #+END_SRC

*** man pages

#+BEGIN_SRC emacs-lisp
(require 'ox-man)
#+END_SRC

# *** wikipedia
#
# #+BEGIN_SRC emacs-lisp
# (use-package ox-mediawiki)
# #+END_SRC

*** Форматированное копирование в буфер обмена

#+BEGIN_SRC emacs-lisp
(use-package ox-clip)
#+END_SRC

*** Org-contrib

#+BEGIN_SRC emacs-lisp
(use-package org-contrib
  :ensure t)

(use-package ox-taskjuggler
  :straight (tree-sitter :type git
                         :host github
                         :repo "h-oll/ox-taskjuggler"
                         :branch "master"
                         :files ("lisp/*.el"))
  :ensure t
  :config
  (setq org-taskjuggler-default-reports
        '("textreport report \"Plan\" {
formats html
header '== %title =='
center -8<-
[#Plan Plan] | [#Resource_Allocation Resource Allocation]
----
=== Plan ===
<[report id=\"plan\"]>
----
=== Resource Allocation ===
<[report id=\"resourceGraph\"]>
->8-
}
# A traditional Gantt chart with a project overview.
taskreport plan \"\" {
headline \"Project Plan\"
# columns bsi, name, start, end, effort, effortdone, effortleft, chart { width 5000 }
columns name, start, end, effort, effortdone, effortleft, chart { width 5000 }
loadunit shortauto
hideresource 1
}
# A graph showing resource allocation. It identifies whether each
# resource is under- or over-allocated for.
resourcereport resourceGraph \"\" {
headline \"Resource Allocation Graph\"
columns no, name, effort, weekly { width 3000 }
loadunit shortauto
hidetask ~(isleaf() & isleaf_())
sorttasks plan.start.up
}"

          "taskreport mytasks \"CSV\" {
             formats csv
             columns id, name, start, end
         }")

        org-taskjuggler-default-project-duration 3000))

(use-package tj3-mode
  :after ox-taskjuggler
  :ensure t
  :config
  (require 'ox-taskjuggler))
#+END_SRC


** Org babel (исполняемые кусочки кода в org-файлах)

Org babel режимы, которые надо поддержать

 #+BEGIN_SRC emacs-lisp
 (defun my-org-confirm-babel-evaluate (lang body)
   (not (or
         (string= lang "latex")
         (string= lang "dot")
         (string= lang "graphviz")
         (string= lang "gnuplot")
         (string= lang "plantuml"))))

 (use-package babel
   :ensure t
   ;; :after
   ;; (org ob-perl ob-shell ob-sql ob-plantuml ob-gnuplot ob-python ob-ocaml)
   :config
   ;; Не просить подтверждение для запуска SRC-блоков
   (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
   ;; Загрузить языки
   (org-babel-do-load-languages
    'org-babel-load-languages
    '((perl . t)
      (shell . t)
      (latex . t)
      (org . t)
      (dot . t)
      (sql . t)
      ;; (coq . t)
      (ocaml . t)
      (plantuml . t)
      (gnuplot 't)
      (emacs-lisp . t))))
 #+END_SRC

** Org capture (шаблоны записей)

*** Супер-шаблоны

 Refile всего поддерева под курсором с подстановкой дат по заданному смещению. Для корневого поддерева должно быть задано SCHEDULED.

 #+BEGIN_SRC emacs-lisp
 (defun my-org-clone-to-date ()
   "Clone current subtree into specified file with all dates shifted to the same period."
   (interactive)
   (let* ((title (nth 4 (org-heading-components)))
          (orig-date (org-time-string-to-absolute (org-entry-get nil "SCHEDULED")))
          (dest-date (org-time-string-to-absolute
                      (org-read-date nil nil nil (format "Дата для '%s'" title))))
          (offset (format "+%id" (- dest-date orig-date))))
     (org-copy-subtree)
     (with-temp-buffer
       (org-mode)
       (org-paste-subtree)
       (org-clone-subtree-with-time-shift 1 offset)
       (org-forward-element)
       (org-refile))))
 #+END_SRC

**** Как использую

 У меня есть шаблоны мероприятий, где описана вся последовательность действий, которые надо совершить при подготовке. В верхнем уровне указан
 SCHEDULED, указывающий, когда мероприятие должно состояться. При выполнении внутри корневого элемента этой функции, создается копия всей
 структуры в указанный файл со смещением дат относительно указанной. Например:

 #+BEGIN_SRC org
 ,* Слёт Сплава [0%]                                                    :Сплав:
   DEADLINE: <2019-05-25 Сб -3d> SCHEDULED: <2019-05-25 Сб>
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :END:

 Ехать до станции Подосинки с Казанского вокзала
 Электричка отходит в ..., стоит ... руб

 Расписание автобусов от Подосинок: ...

 Расписание автобусов от лагеря: ...

 ,** TODO Список вещей
    SCHEDULED: <2019-05-22 Ср>

 2 баллона газа
 Продукты
 Усы
 Каска
 ...

 ,** TODO Узнать расписание электричек, запланировать
    SCHEDULED: <2019-05-22 Ср>
 ,** TODO Узнать расписание автобусов в [[https://vk.com/splavclub][группе]].
    SCHEDULED: <2019-05-22 Ср>
 ,** TODO Карта на GPS
    SCHEDULED: <2019-05-21 Вт>

 В архиве карт на GPS лежит splav.img

 ,** TODO Снять деньги
    SCHEDULED: <2019-05-23 Чт>

 ,** TODO Продумать раскладку по еде
    SCHEDULED: <2019-05-21 Вт>

 #+END_SRC

 *Важно*: фича реализована через функицю ~org-clone-subtree-with-time-shift~, и она слишком умно интерпретирует repeated tasks. Поэтому если
 в плане подготовки какой-то таск надо повторять (пример: перед поездкой в горы трижды в неделю запланировать бег), то таск надо
 раскопировать вручную, заранее расставив даты со смещением.

** Прочие Org-фичи

# *** Менеджер паролей

#  #+BEGIN_SRC emacs-lisp
#  (use-package
#    org-password-manager
#    :after (org)
#    :hook (org-mode . org-password-manager-key-bindings))
#  #+END_SRC

*** Таблицы

 При сохранении org-файлов автоматом форматировать таблицы в нём:

 #+BEGIN_SRC emacs-lisp
 (defun my-org-mode-on-save-buffer-setup ()
   (add-hook 'before-save-hook #'org-table-iterate-buffer-tables nil 'make-it-local))

 (use-package
   org-table
   :after (org)
   :hook (org-mode . my-org-mode-on-save-buffer-setup))
 #+END_SRC

*** Заархивировать все завершенные задачи в буфере

 #+BEGIN_SRC emacs-lisp
 (defun my-org-archive-done-tasks ()
   "Archive all DONE tasks in current buffer"
   (interactive)
   (org-map-entries
    (lambda ()
      (org-archive-subtree)
      (setq org-map-continue-from (outline-previous-heading)))
    "/DONE" 'file))
 #+END_SRC

** Obsidian

Org-подобная система, модно-молодежная.

#+BEGIN_SRC emacs-lisp
(use-package obsidian
  :ensure t
  :demand t
  :config
  (global-obsidian-mode t)
  :custom
  ;; This directory will be used for `obsidian-capture' if set.
  (obsidian-inbox-directory "Inbox")
  ;; Create missing files in inbox? - when clicking on a wiki link
  ;; t: in inbox, nil: next to the file with the link
  ;; default: t
  ;(obsidian-wiki-link-create-file-in-inbox nil)
  ;; The directory for daily notes (file name is YYYY-MM-DD.md)
  (obsidian-daily-notes-directory "Daily Notes")
  ;; Directory of note templates, unset (nil) by default
  ;(obsidian-templates-directory "Templates")
  ;; Daily Note template name - requires a template directory. Default: Daily Note Template.md
  ;(obsidian-daily-note-template "Daily Note Template.md")
  :bind (:map obsidian-mode-map
  ;; Replace C-c C-o with Obsidian.el's implementation. It's ok to use another key binding.
  ("C-c C-o" . obsidian-follow-wiki-link-at-point)
  ;; Jump to backlinks
  ("C-c C-b" . obsidian-backlink-jump)
  ;; If you prefer you can use `obsidian-insert-link'
  ("C-c C-l" . obsidian-insert-wikilink)))
#+END_SRC


** Spell-checking

 #+BEGIN_SRC emacs-lisp
 (use-package
   flyspell
  ;  :ensure-system-package (ispell aspell-en aspell-ru)
   :hook ((text-mode . turn-on-flyspell)
          (prog-mode . flyspell-prog-mode))
   :commands (flyspell-buffer turn-on-flyspell)
   :config
   ;; Использовать aspell, если доступен
   (when (executable-find "aspell")
     (setq ispell-program-name "aspell")
     (setq ispell-list-command "--list"))
   ;; ;; Переключаем язык проверки по переключению раскладки
   (defadvice my-select-input-eng (after ispell-american activate) (ispell-change-dictionary "american"))
   (defadvice my-select-input-rus (after ispell-russian activate) (ispell-change-dictionary "ru")))
 #+END_SRC

 Включаем ленивую проверку, когда ничего не происходит:

 #+BEGIN_SRC emacs-lisp
 (use-package
   flyspell-lazy
   :config
   (setq flyspell-lazy-idle-seconds 1)
   ;; Проверять все буферы, включая временные типа *scratch* и буферов Gnus
   (setq flyspell-lazy-disallow-buffers nil)   (flyspell-lazy-mode 1))
 #+END_SRC
** Helm

 #+BEGIN_SRC emacs-lisp
 (use-package helm-org-rifle)
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
 (use-package
   helm
   :after (helm-org-rifle recentf)
   :bind (:map my-bindings-map
               ("M-s M-s" . my-helm-search-all))
   :preface
   (defvar my-helm-sources)
   ;; Функция ищет по всем подключенным источникам
   (defun my-helm-search-all ()
	 (interactive)
	 (let ((sources (append (helm-org-rifle-get-sources-for-open-buffers) my-helm-sources)))
	   (unless helm-source-buffers-list
		 (setq helm-source-buffers-list
			   (helm-make-source "Buffers" 'helm-source-buffers)))
	   (helm :sources sources
			 :buffer "*helm completions*")))
   :config
   (require 'helm-for-files)
   (require 'helm-elisp)
   (setq helm-split-window-in-side-p t
         helm-M-x-fuzzy-match t
         helm-buffers-fuzzy-matching t
         helm-recentf-fuzzy-match t
         projectile-completion-system 'helm)
   (setq helm-input-idle-delay 0.1)
   (setq my-helm-sources
		 '(helm-source-buffers-list
		   helm-source-recentf
		   helm-source-info-pages
		   helm-source-complex-command-history
		   helm-source-etags-select
		   helm-source-grep-ag
		   helm-source-bookmarks))
   (helm-adaptive-mode 1))
 #+END_SRC

 #+BEGIN_SRC emacs-lisp
 (use-package helm-descbinds
   :after helm
   :config
   (helm-descbinds-mode))
 #+END_SRC

** Gnus

 Функция для обрезания сообщения до сигнатуры:

 #+BEGIN_SRC emacs-lisp
 (defun my-gnus-zap-to-signature ()
   (interactive)
   (let ((curpos (point))
		 (endpos (re-search-forward "\n-- " nil t 1)))
	 (if (not (eq endpos nil))
		 (progn
		   (kill-region curpos (match-beginning 0))
		   (goto-char curpos)
		   (open-line 1)))))
 #+END_SRC

 Проверить почту через offlineimap:

 #+BEGIN_SRC emacs-lisp
 (defun my-gnus-update-news-external ()
   (interactive)
   (progn
     (message "Checking new news from external sources...")
     (call-process-shell-command "(offlineimap -o -1; notmuch new) &>/dev/null &" nil 0)
     (gnus-group-get-new-news)))
 #+END_SRC

Настройка буфера написания сообщения:

#+BEGIN_SRC emacs-lisp
(defun my-message-mode-setup ()
  (when message-this-is-mail
    ;; Использовать логические строчки, не вставлять ньюлайны
    (turn-off-auto-fill)
    (setq fill-column 140
          visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
    (visual-line-mode)
    (visual-fill-column-mode)))
#+END_SRC

 #+BEGIN_SRC emacs-lisp
 (use-package gnus
   :demand t
   :commands (gnus)
   :hook ((message-mode . turn-on-flyspell)
          (message-mode . my-message-mode-setup)
          (message-send . ispell-message)
          (gnus-summary-mode . hl-line-mode)
          (gnus-group-mode . hl-line-mode)
          (gnus-message-setup . mml-secure-message-sign-pgpmime))
   :bind (:map message-mode-map
               ("M-z" . my-gnus-zap-to-signature)
               :map gnus-group-mode-map
               ("M-g" . my-gnus-update-news-external))
   :config
   ;; Надо определить переменные
   (require 'gnus-msg)

   ;; Свежий gnus перестал самостоятельно находить
   ;; Лечит ошибку: Mail source (file) error (Searching for program)
   (setq mail-source-movemail-program "/usr/bin/movemail")

   ;; Выставить таймаут на коннект к NNTP
   (setq nntp-connection-timeout 5)

   ;; Периодический полл источников
   (gnus-demon-add-handler 'gnus-demon-scan-news 1200 300)
   (gnus-demon-init)

   ;; Какой браузер использовать
   ;; (setq gnus-button-url 'browse-url-generic
   ;;       browse-url-generic-program "x-www-browser"
   ;;       browse-url-browser-function gnus-button-url)

   ;; По умолчанию во всех группах делать копию отправляемого письма себе
   (setq gnus-parameters
         '((".*"
            (gcc-self . t))))

   ;; Перед сохранением аттача имеет смысл нажать [A C], чтобы вытянуть сообщение целиком
   (setq nnimap-fetch-partial-articles "text/")

   ;; Обнуляем основной источник писем
   (setq gnus-select-method '(nnnil ""))

   ;; Подключить дополнительные источники
   (setq gnus-secondary-select-methods
         ;; Получение через IMAP с локалхоста
         '(
           ;; UNIX mailbox
           (nnmbox "LocalMBOX")
           ;; Читаем RSS/Atom через ньюсгруппы
           (nntp "news.gwene.org"
                 (nntp-connection-timeout 120))))

   ;; Способ оформления цитаты
   (setq message-citation-line-function 'message-insert-formatted-citation-line)

   ;; Отправленные сообщения метить прочитанными (TODO работает ли?)
   (setq gnus-gcc-mark-as-read t)

   ;; В наши трудные времена надо хотя бы сделать вид, что ты обеспечиваешь безопасность переписки
   (setq mml2015-use 'epg
         ;; немного дебага
         mml2015-verbose t
         ;; шифровать и для себя
         mml-secure-openpgp-encrypt-to-self t
         ;; проверять подпись и у зашифрованных сообщений(?)
         mml-secure-openpgp-always-trust nil
         ;; кэшировать пароль от хранилища ключей
         mml-secure-cache-passphrase t
         ;; кэшировать пароль от хранилища на 10 часов
         mml-secure-passphrase-cache-expiry '36000
         ;; определять используемый ключ при подписи по адресу отправителя
         mml-secure-openpgp-sign-with-sender t
         ;; всегда спрашивать, надо ли расшифровать зашифрованный парт письма
         mm-decrypt-option nil
         ;; всегда проверять достоверность подписанного парта
         mm-verify-option 'always)

   ;; зашифрованные парты и подписи надо показывать кнопкой
   (add-to-list 'gnus-buttonized-mime-types "multipart/signed")
   (add-to-list 'gnus-buttonized-mime-types "multipart/encrypted")

   ;; Наводим красоты
   (setq gnus-group-line-format "%M%S%5y%6t: %(%g%)\n"
         gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
         gnus-summary-line-format "%U%R %&user-date; %B %[%-23,23a%] %s\n")

   (when window-system
     (setq gnus-sum-thread-tree-indent "  "
           gnus-sum-thread-tree-root "● "
           gnus-sum-thread-tree-false-root "◯ "
           gnus-sum-thread-tree-single-indent "◎ "
           gnus-sum-thread-tree-vertical        "│"
           gnus-sum-thread-tree-leaf-with-other "├─► "
           gnus-sum-thread-tree-single-leaf     "╰─► "))
   )
 #+END_SRC

** Языковые модели   

*** ChatGPT шелл

#+BEGIN_SRC emacs-lisp
(use-package shell-maker
  :ensure t
  :straight (:type git
                   :host github
                   :repo "xenodium/shell-maker"
                   :files ("*.el")))

(use-package chatgpt-shell
  :ensure t
  :straight (:type git :host github :repo "xenodium/chatgpt-shell" :files ("chatgpt-shell*.el"))
  :custom
  (chatgpt-shell-openai-key
    (lambda ()
      (auth-source-pass-get 'secret "personal/openai-emacs-key"))))
#+END_SRC

*** Claude code

#+BEGIN_SRC emacs-lisp
(use-package vterm :ensure t)

(use-package transient
  :ensure t
  :straight (:type git
                   :host github
                   :repo "magit/transient"))

(use-package claude-code
  :after transient
  :straight (:type git
                   :host github
                   :repo "stevemolitor/claude-code.el"
                   :files ("*.el" (:exclude "images/*")))
  :bind-keymap
  ("C-c x" . claude-code-command-map) ;; or your preferred key
  :config
  (setq claude-code-terminal-backend 'vterm)
  (defun my-claude-notify (title message)
    "Display a Linux notification using notify-send."
    (if (executable-find "notify-send")
        (call-process "notify-send" nil nil nil title message)
      (message "%s: %s" title message)))
  (setq claude-code-notification-function #'my-claude-notify)
  (claude-code-mode))
#+END_SRC



*** Автоматическое формирование коммит-сообщений

#+BEGIN_SRC emacs-lisp
(use-package plz-media-type
  ;; :ensure t
)

(use-package llm-openai
  ;; :ensure t
)

(use-package magit-gptcommit
  ;; :straight t
  :ensure t
  :after magit
  :bind (:map git-commit-mode-map
              ("C-c C-g" . magit-gptcommit-commit-accept))
  :custom
  (require 'llm-openai)
  (magit-gptcommit-llm-provider (make-llm-openai :key (auth-source-pass-get 'secret "personal/openai-emacs-key")))

  :config
  ;; Enable magit-gptcommit-mode to watch staged changes and generate commit message automatically in magit status buffer
  ;; This mode is optional, you can also use `magit-gptcommit-generate' to generate commit message manually
  ;; `magit-gptcommit-generate' should only execute on magit status buffer currently
  ;; (magit-gptcommit-mode 1)

  ;; Add gptcommit transient commands to `magit-commit'
  ;; Eval (transient-remove-suffix 'magit-commit '(1 -1)) to remove gptcommit transient commands
  (magit-gptcommit-status-buffer-setup))
#+END_SRC


** Dired

 Обновлять буферы dired автоматом при изменении директории:

 #+BEGIN_SRC emacs-lisp
 (add-hook 'dired-mode-hook 'auto-revert-mode)
 #+END_SRC

** Спортивные утилиты

 #+BEGIN_SRC emacs-lisp
 (defun sport/equipment-report-weights (src)
   "Return summary weights grouped by buggage type"
   (let
       ((vals
         (let ((cols (- (length (first src)) 2)))
                 (seq-reduce '(lambda (sums row)
                                (mapcar*
                                 '(lambda (v s)
                                    (+ (* (number-or-v v 0) (lst-number-or-v row 1 0)) s))
                                 (nthcdr 2 row)
                                 sums))
                             (cdr src)
                             (make-list cols 0)))))
     (list
      (cons "ИТОГО" (nthcdr 2 (first src)))
      'hline
      (cons (seq-reduce #'+ vals 0) vals))))

 (defun sport/equipment-report-baggage (src pos)
   "Return list for specified buggage type (column position in src table)"
   (cons
    '("" "Вес" "Кол-во")
    (cons
     'hline
     (sort 
      (remove-if-not
       '(lambda (row) (> (nth 1 row) 0))
       (map
        #'list
        '(lambda (row)
           (let ((name (first row))
                 (cnt (lst-number-or-v row pos 0)))
             (list name (* (lst-number-or-v row 1 0) cnt) cnt)))
        (cdr src)))
      (lambda (a b) (> (nth 1 a) (nth 1 b)))))))

 (defun sport/equipment-report-shared (src)
   "Return list for specified buggage type (column position in src table)"
   (cons
    '("" "Вес" "Кол-во")
    (cons
     'hline
     (sort 
       (map
        #'list
        '(lambda (row)
           (list
            (first row)
            (lst-number-or-v row 1 0)
            (lst-number-or-v row 6 0)))
        (remove-if
         '(lambda (row) (= (lst-number-or-v row 6 0) 0))
         (cdr src)))
       (lambda (a b) (string< (nth 0 a) (nth 0 b)))))))

 (defun my-sport-journal-add (type value notes)
   (interactive
    (list
     (completing-read
      "Тип: "
      (with-current-buffer (find-file-noselect "~/org/personal/sport/sports-periodic-TODO.org")
        (outline-show-all)
        (goto-char (point-min))
        (setq case-fold-search nil)
        (re-search-forward "^#\\+NAME: sports-journal")
        (next-line)
        (mapcar
         (lambda (row) (car (cdr row)))
         (seq-filter (lambda (row) (not (eq row 'hline))) (org-table-to-lisp)))))
     (read-string "Значение: ")
     (read-string "Заметки: ")))
   ;; TODO: improve
   (with-current-buffer (find-file-noselect "~/org/personal/sport/sports-periodic-TODO.org")
     (goto-char (point-min))
     (setq case-fold-search nil)
     (re-search-forward "^#\\+NAME: sports-journal")
     (next-line)
     (goto-char (org-table-end))
     (insert
      (format "| [%s] | %s | | %s | %s |\n" (format-time-string "%F %R") type value notes))))
 #+END_SRC

** Прочее

*** Календарь

 #+BEGIN_SRC emacs-lisp
 (use-package
   calendar
   :ensure nil
   :config
   (setq calendar-location-name "Moscow"
         calendar-latitude 55.5
         calendar-longitude 37.4)
   ;; Хочу русский календарь!
   (setq calendar-week-start-day 1
		 calendar-day-abbrev-array ["Вс" "Пн" "Вт" "Ср" "Чт" "Пт" "Сб"]
		 calendar-day-header-array calendar-day-abbrev-array
		 calendar-day-name-array ["Воскресенье" "Понедельник" "Вторник" "Среда" "Четверг" "Пятница" "Суббота"]
		 calendar-month-name-array ["Январь" "Февраль" "Март" "Апрель" "Май" 
								    "Июнь" "Июль" "Август" "Сентябрь"
								    "Октябрь" "Ноябрь" "Декабрь"]))
 #+END_SRC

 Русские праздники:

 #+BEGIN_SRC emacs-lisp
 (use-package
   russian-holidays
   :after (calendar)
   :config
   (setq calendar-holidays russian-holidays))

 #+END_SRC


*** Финансы

#+BEGIN_SRC emacs-lisp
(use-package
  org-expenses
  :load-path "~/.emacs.d/public/org-expenses"
  :bind (:map my-bindings-map
              ("C-c f" . org-expenses/expense-view))
  :config
  (setq org-expenses/files "~/org/personal"))
#+END_SRC


*** Вспомогательные функции

#+BEGIN_SRC emacs-lisp
(defun number-or-v (n v)
  "Return V if N is not a number, or N otherwise."
  (if (not (numberp n)) v n))

(defun lst-number-or-v (lst pos v)
  "Return V if list element at POS is not a number, or (nth POS LST) otherwise."
  (number-or-v (nth pos lst) v))
#+END_SRC


** Загрузка локальных настроек

#+BEGIN_SRC emacs-lisp
(my-load-org-config "local.org")
#+END_SRC
